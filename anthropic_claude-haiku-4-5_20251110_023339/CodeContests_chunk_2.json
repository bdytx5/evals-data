[{"sample_id": 23, "input": "Write a Python3 function named `solve` with typed input arguments for this problem:\n\nKawasiro Nitori is excellent in engineering. Thus she has been appointed to help maintain trains.\n\nThere are n models of trains, and Nitori's department will only have at most one train of each model at any moment. In the beginning, there are no trains, at each of the following m days, one train will be added, or one train will be removed. When a train of model i is added at day t, it works for x_i days (day t inclusive), then it is in maintenance for y_i days, then in work for x_i days again, and so on until it is removed.\n\nIn order to make management easier, Nitori wants you to help her calculate how many trains are in maintenance in each day.\n\nOn a day a train is removed, it is not counted as in maintenance.\n\nInput\n\nThe first line contains two integers n, m (1 \u2264 n,m \u2264 2 \u22c5 10^5).\n\nThe i-th of the next n lines contains two integers x_i,y_i (1 \u2264 x_i,y_i \u2264 10^9).\n\nEach of the next m lines contains two integers op, k (1 \u2264 k \u2264 n, op = 1 or op = 2). If op=1, it means this day's a train of model k is added, otherwise the train of model k is removed. It is guaranteed that when a train of model x is added, there is no train of the same model in the department, and when a train of model x is removed, there is such a train in the department.\n\nOutput\n\nPrint m lines, The i-th of these lines contains one integers, denoting the number of trains in maintenance in the i-th day.\n\nExamples\n\nInput\n\n\n3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n\n\nOutput\n\n\n0\n1\n0\n0\n\n\nInput\n\n\n5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n\n\nOutput\n\n\n0\n0\n0\n1\n\nNote\n\nConsider the first example:\n\nThe first day: Nitori adds a train of model 3. Only a train of model 3 is running and no train is in maintenance.\n\nThe second day: Nitori adds a train of model 1. A train of model 1 is running and a train of model 3 is in maintenance.\n\nThe third day: Nitori removes a train of model 1. The situation is the same as the first day.\n\nThe fourth day: Nitori removes a train of model 3. There are no trains at all.\n\nReturn only a valid Python function that returns the result. No comments, no explanations. Include necessary imports for libraries. DO NOT include a main function or if __name__ == '__main__' block. JUST write the function with proper imports.", "output": "```python\ndef solve(n: int, m: int, trains: list[tuple[int, int]], operations: list[tuple[int, int]]) -> list[int]:\n    results = []\n    active_trains = {}\n    \n    for day in range(1, m + 1):\n        op, k = operations[day - 1]\n        \n        if op == 1:\n            x, y = trains[k - 1]\n            active_trains[k] = (day, x, y)\n        else:\n            if k in active_trains:\n                del active_trains[k]\n        \n        maintenance_count = 0\n        for train_id, (add_day, x, y) in active_trains.items():\n            days_since_add = day - add_day\n            cycle_length = x + y\n            position_in_cycle = days_since_add % cycle_length\n            \n            if position_in_cycle >= x:\n                maintenance_count += 1\n        \n        results.append(maintenance_count)\n    \n    return results\n```", "ground_truth": "", "score": {"correct": false, "additional_outputs_to_log": {"test_results": [{"test_index": 0, "input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "expected_output": "0\n1\n0\n0\n", "actual_output": "ERROR: Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 9, in solve\nIndexError: list index out of range", "passed": false, "error": "Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 9, in solve\nIndexError: list index out of range"}, {"test_index": 1, "input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "expected_output": "0\n0\n0\n1\n", "actual_output": "[0, 0, 0, 1]", "passed": true, "error": null}]}}, "latency_seconds": 2.0589, "additional_outputs": {"test_results": [{"test_index": 0, "input": "3 4\n10 15\n12 10\n1 1\n1 3\n1 1\n2 1\n2 3\n", "expected_output": "0\n1\n0\n0\n", "actual_output": "ERROR: Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 9, in solve\nIndexError: list index out of range", "passed": false, "error": "Traceback (most recent call last):\n  File \"<string>\", line 28, in <module>\n  File \"<string>\", line 9, in solve\nIndexError: list index out of range"}, {"test_index": 1, "input": "5 4\n1 1\n10000000 100000000\n998244353 1\n2 1\n1 2\n1 5\n2 5\n1 5\n1 1\n", "expected_output": "0\n0\n0\n1\n", "actual_output": "[0, 0, 0, 1]", "passed": true, "error": null}]}}, {"sample_id": 21, "input": "Write a Python3 function named `solve` with typed input arguments for this problem:\n\nCQXYM found a rectangle A of size n \u00d7 m. There are n rows and m columns of blocks. Each block of the rectangle is an obsidian block or empty. CQXYM can change an obsidian block to an empty block or an empty block to an obsidian block in one operation.\n\nA rectangle M size of a \u00d7 b is called a portal if and only if it satisfies the following conditions:\n\n  * a \u2265 5,b \u2265 4. \n  * For all 1 < x < a, blocks M_{x,1} and M_{x,b} are obsidian blocks. \n  * For all 1 < x < b, blocks M_{1,x} and M_{a,x} are obsidian blocks. \n  * For all 1<x<a,1<y<b, block M_{x,y} is an empty block. \n  * M_{1, 1}, M_{1, b}, M_{a, 1}, M_{a, b} can be any type. \n\nNote that the there must be a rows and b columns, not b rows and a columns.\n\nNote that corners can be any type\n\nCQXYM wants to know the minimum number of operations he needs to make at least one sub-rectangle a portal.\n\nInput\n\nThe first line contains an integer t (t \u2265 1), which is the number of test cases.\n\nFor each test case, the first line contains two integers n and m (5 \u2264 n \u2264 400, 4 \u2264 m \u2264 400). \n\nThen n lines follow, each line contains m characters 0 or 1. If the j-th character of i-th line is 0, block A_{i,j} is an empty block. Otherwise, block A_{i,j} is an obsidian block.\n\nIt is guaranteed that the sum of n over all test cases does not exceed 400.\n\nIt is guaranteed that the sum of m over all test cases does not exceed 400.\n\nOutput\n\nOutput t answers, and each answer in a line.\n\nExamples\n\nInput\n\n\n1\n5 4\n1000\n0000\n0110\n0000\n0001\n\n\nOutput\n\n\n12\n\n\nInput\n\n\n1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n\n\nOutput\n\n\n5\n\nNote\n\nIn the first test case, the final portal is like this:\n    \n    \n      \n    1110  \n    1001  \n    1001  \n    1001  \n    0111\n\nReturn only a valid Python function that returns the result. No comments, no explanations. Include necessary imports for libraries. DO NOT include a main function or if __name__ == '__main__' block. JUST write the function with proper imports.", "output": "```python\ndef solve() -> None:\n    t = int(input())\n    for _ in range(t):\n        n, m = map(int, input().split())\n        grid = []\n        for i in range(n):\n            grid.append(input().strip())\n        \n        min_ops = float('inf')\n        \n        # Try all possible portals of size a x b where a >= 5, b >= 4\n        for a in range(5, n + 1):\n            for b in range(4, m + 1):\n                # Try all possible top-left corners (r, c)\n                for r in range(n - a + 1):\n                    for c in range(m - b + 1):\n                        # Calculate operations needed for this portal\n                        ops = 0\n                        \n                        # Check top and bottom rows (excluding corners can be anything)\n                        for y in range(1, b - 1):\n                            # Top row, position (r, c+y)\n                            if grid[r][c + y] == '0':\n                                ops += 1\n                            # Bottom row, position (r+a-1, c+y)\n                            if grid[r + a - 1][c + y] == '0':\n                                ops += 1\n                        \n                        # Check left and right columns (excluding corners can be anything)\n                        for x in range(1, a - 1):\n                            # Left column, position (r+x, c)\n                            if grid[r + x][c] == '0':\n                                ops += 1\n                            # Right column, position (r+x, c+b-1)\n                            if grid[r + x][c + b - 1] == '0':\n                                ops += 1\n                        \n                        # Check interior (all must be empty)\n                        for x in range(1, a - 1):\n                            for y in range(1, b - 1):\n                                if grid[r + x][c + y] == '1':\n                                    ops += 1\n                        \n                        min_ops = min(min_ops, ops)\n        \n        print(min_ops)\n\nsolve()\n```", "ground_truth": "", "score": {"correct": false, "additional_outputs_to_log": {"test_results": [{"test_index": 0, "input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "expected_output": "5\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 1, "input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "expected_output": "12\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}]}}, "latency_seconds": 3.2329, "additional_outputs": {"test_results": [{"test_index": 0, "input": "1\n9 9\n001010001\n101110100\n000010011\n100000001\n101010101\n110001111\n000001111\n111100000\n000110000\n", "expected_output": "5\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 1, "input": "1\n5 4\n1000\n0000\n0110\n0000\n0001\n", "expected_output": "12\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}]}}, {"sample_id": 22, "input": "Write a Python3 function named `solve` with typed input arguments for this problem:\n\nLet c_1, c_2, \u2026, c_n be a permutation of integers 1, 2, \u2026, n. Consider all subsegments of this permutation containing an integer x. Given an integer m, we call the integer x good if there are exactly m different values of maximum on these subsegments.\n\nCirno is studying mathematics, and the teacher asks her to count the number of permutations of length n with exactly k good numbers.\n\nUnfortunately, Cirno isn't good at mathematics, and she can't answer this question. Therefore, she asks you for help.\n\nSince the answer may be very big, you only need to tell her the number of permutations modulo p.\n\nA permutation is an array consisting of n distinct integers from 1 to n in arbitrary order. For example, [2,3,1,5,4] is a permutation, but [1,2,2] is not a permutation (2 appears twice in the array) and [1,3,4] is also not a permutation (n=3 but there is 4 in the array).\n\nA sequence a is a subsegment of a sequence b if a can be obtained from b by deletion of several (possibly, zero or all) elements from the beginning and several (possibly, zero or all) elements from the end.\n\nInput\n\nThe first line contains four integers n, m, k, p (1 \u2264 n \u2264 100, 1 \u2264 m \u2264 n, 1 \u2264 k \u2264 n, 1 \u2264 p \u2264 10^9).\n\nOutput\n\nOutput the number of permutations modulo p.\n\nExamples\n\nInput\n\n\n4 3 2 10007\n\n\nOutput\n\n\n4\n\n\nInput\n\n\n6 4 1 769626776\n\n\nOutput\n\n\n472\n\n\nInput\n\n\n66 11 9 786747482\n\n\nOutput\n\n\n206331312\n\n\nInput\n\n\n99 30 18 650457567\n\n\nOutput\n\n\n77365367\n\nNote\n\nIn the first test case, there are four permutations: [1, 3, 2, 4], [2, 3, 1, 4], [4, 1, 3, 2] and [4, 2, 3, 1].\n\nTake permutation [1, 3, 2, 4] as an example:\n\nFor number 1, all subsegments containing it are: [1], [1, 3], [1, 3, 2] and [1, 3, 2, 4], and there're three different maxima 1, 3 and 4.\n\nSimilarly, for number 3, there're two different maxima 3 and 4. For number 2, there're three different maxima 2, 3 and 4. And for number 4, there're only one, that is 4 itself.\n\nReturn only a valid Python function that returns the result. No comments, no explanations. Include necessary imports for libraries. DO NOT include a main function or if __name__ == '__main__' block. JUST write the function with proper imports.", "output": "```python\nfrom functools import lru_cache\n\ndef solve(n: int, m: int, k: int, p: int) -> int:\n    @lru_cache(maxsize=None)\n    def count_good(value: int, perm: tuple) -> int:\n        \"\"\"Count how many different maxima appear in subsegments containing value\"\"\"\n        pos = perm.index(value)\n        maxima = set()\n        \n        # Expand left from position\n        current_max = value\n        for i in range(pos, -1, -1):\n            current_max = max(current_max, perm[i])\n            maxima.add(current_max)\n        \n        # Expand right from position\n        current_max = value\n        for i in range(pos, len(perm)):\n            current_max = max(current_max, perm[i])\n            maxima.add(current_max)\n        \n        return len(maxima)\n    \n    @lru_cache(maxsize=None)\n    def generate_and_count(remaining: tuple, current: tuple) -> int:\n        \"\"\"Generate all permutations and count those with exactly k good numbers\"\"\"\n        if not remaining:\n            # Check how many good numbers this permutation has\n            good_count = 0\n            for value in range(1, n + 1):\n                if count_good(value, current) == m:\n                    good_count += 1\n            \n            if good_count == k:\n                return 1\n            else:\n                return 0\n        \n        total = 0\n        for i, val in enumerate(remaining):\n            new_remaining = remaining[:i] + remaining[i+1:]\n            new_current = current + (val,)\n            total = (total + generate_and_count(new_remaining, new_current)) % p\n        \n        return total\n    \n    initial_remaining = tuple(range(1, n + 1))\n    result = generate_and_count(initial_remaining, ())\n    return result\n```\n\nWait, this approach is too slow for n=100. Let me reconsider with a better algorithm using dynamic programming.\n\n```python\nfrom functools import lru_cache\nfrom math import factorial\n\ndef solve(n: int, m: int, k: int, p: int) -> int:\n    def count_good_values(perm: tuple) -> int:\n        \"\"\"Count how many values are 'good' (have exactly m different maxima in subsegments)\"\"\"\n        good_count = 0\n        \n        for value in range(1, n + 1):\n            pos = perm.index(value)\n            maxima = set()\n            \n            # All subsegments containing value\n            for left in range(pos + 1):\n                for right in range(pos, n):\n                    segment_max = max(perm[left:right + 1])\n                    maxima.add(segment_max)\n            \n            if len(maxima) == m:\n                good_count += 1\n        \n        return good_count\n    \n    def generate_perms(arr: list) -> list:\n        \"\"\"Generate all permutations\"\"\"\n        if len(arr) <= 1:\n            return [tuple(arr)]\n        \n        result = []\n        for i in range(len(arr)):\n            rest = arr[:i] + arr[i+1:]\n            for perm in generate_perms(rest):\n                result.append((arr[i],) + perm)\n        return result\n    \n    count = 0\n    perms = generate_perms(list(range(1, n + 1)))\n    \n    for perm in perms:\n        if count_good_values(perm) == k:\n            count = (count + 1) % p\n    \n    return count\n```", "ground_truth": "", "score": {"correct": false, "additional_outputs_to_log": {"test_results": [{"test_index": 0, "input": "6 4 1 769626776\n", "expected_output": "472\n", "actual_output": "472", "passed": true, "error": null}, {"test_index": 1, "input": "99 30 18 650457567\n", "expected_output": "77365367\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 2, "input": "66 11 9 786747482\n", "expected_output": "206331312\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 3, "input": "4 3 2 10007\n", "expected_output": "4\n", "actual_output": "4", "passed": true, "error": null}]}}, "latency_seconds": 5.9517, "additional_outputs": {"test_results": [{"test_index": 0, "input": "6 4 1 769626776\n", "expected_output": "472\n", "actual_output": "472", "passed": true, "error": null}, {"test_index": 1, "input": "99 30 18 650457567\n", "expected_output": "77365367\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 2, "input": "66 11 9 786747482\n", "expected_output": "206331312\n", "actual_output": "ERROR: Execution timed out.", "passed": false, "error": "Execution timed out."}, {"test_index": 3, "input": "4 3 2 10007\n", "expected_output": "4\n", "actual_output": "4", "passed": true, "error": null}]}}]